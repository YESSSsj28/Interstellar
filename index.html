<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple First-Person Map</title>
    <style>
        /* Basic Setup */
        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #333;
            font-family: sans-serif;
            color: white;
            display: flex; /* Use flexbox for centering */
            justify-content: center;
            align-items: center;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10; /* Ensure it's above the scene */
            max-width: 250px;
        }

        /* Scene Setup */
        .scene {
            width: 100%; /* Take full viewport width */
            height: 100%; /* Take full viewport height */
            perspective: 800px; /* Closer perspective for FP */
            perspective-origin: 50% 50%; /* View from center */
            position: relative; /* Needed for absolute positioning of world */
        }

        .world {
            width: 100%; /* Doesn't really define world size, transforms do */
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            /* Initial position/rotation will be set by JS */
            /* Add transition for smoother visual updates ONLY if needed,
               but direct manipulation in game loop is often better */
            /* transition: transform 0.05s linear; */
        }

        /* Map Element Base Styles */
        .map-element {
            position: absolute;
            /* Center elements by default - easier for translation logic */
            top: 50%;
            left: 50%;
            transform-style: preserve-3d;
            background-color: rgba(150, 150, 150, 0.9);
            border: 1px solid rgba(50, 50, 50, 0.9);
            box-sizing: border-box;
            /* Backface culling can improve performance slightly */
            backface-visibility: hidden;
        }

        /* Map Dimensions (using CSS variables) */
        :root {
            --map-width: 800px;
            --map-depth: 800px;
            --wall-height: 200px; /* Taller walls for FP */
            --box-size: 60px; /* Size of the hideable boxes */
            --player-height: 50px; /* How high the 'camera' is off the ground */
        }

        /* --- Environment Elements --- */

        .floor {
            width: var(--map-width);
            height: var(--map-depth);
            background-color: #5a8a5a; /* Greenish floor */
            /* Rotate flat and position it relative to world origin (0,0,0) */
            transform: translate(-50%, -50%) rotateX(90deg) translateZ(0px); /* Floor at Y=0 */
        }

        .ceiling { /* Optional: Add a ceiling */
             width: var(--map-width);
             height: var(--map-depth);
             background-color: #777;
             transform: translate(-50%, -50%) rotateX(-90deg) translateZ(calc(var(--wall-height) * -1));
             opacity: 0.8;
        }


        /* --- Walls --- */
        .wall {
            width: var(--map-width);
            height: var(--wall-height);
            background-color: #8b7e66; /* Tan walls */
            transform-origin: center center;
            /* Position walls based on world origin */
        }

        .wall-front {
            transform: translate(-50%, -50%) translateY(calc(var(--wall-height)/-2)) translateZ(calc(var(--map-depth) / 2));
        }

        .wall-back {
            transform: translate(-50%, -50%) translateY(calc(var(--wall-height)/-2)) rotateY(180deg) translateZ(calc(var(--map-depth) / 2));
        }

        .wall-left {
            width: var(--map-depth);
            transform: translate(-50%, -50%) translateY(calc(var(--wall-height)/-2)) rotateY(-90deg) translateZ(calc(var(--map-width) / 2));
        }

        .wall-right {
            width: var(--map-depth);
            transform: translate(-50%, -50%) translateY(calc(var(--wall-height)/-2)) rotateY(90deg) translateZ(calc(var(--map-width) / 2));
        }

        /* --- Boxes / Obstacles --- */
        .box {
            width: var(--box-size);
            height: var(--box-size);
            background-color: #8B4513; /* SaddleBrown */
            /* We need 6 faces for a cube */
        }
        .box-face {
             position: absolute;
             width: 100%;
             height: 100%;
             background-color: inherit; /* Inherit color from parent .box */
             border: 1px solid #5a2d0c;
             opacity: 0.95;
             backface-visibility: hidden;
        }

        /* Position the faces of a box */
        .face-front  { transform: translateZ(calc(var(--box-size) / 2)); }
        .face-back   { transform: rotateY(180deg) translateZ(calc(var(--box-size) / 2)); }
        .face-left   { transform: rotateY(-90deg) translateZ(calc(var(--box-size) / 2)); }
        .face-right  { transform: rotateY(90deg) translateZ(calc(var(--box-size) / 2)); }
        .face-top    { transform: rotateX(90deg) translateZ(calc(var(--box-size) / 2)); }
        .face-bottom { transform: rotateX(-90deg) translateZ(calc(var(--box-size) / 2)); }

        /* Specific Box Positions (Translate the whole box group) */
        /* Remember Y=0 is floor level. We need to lift boxes half their height */
        #box1 {
            transform: translate3d(-150px, calc(var(--box-size)/-2), 100px);
        }
        #box2 {
            transform: translate3d(180px, calc(var(--box-size)/-2), -50px);
        }
         #box3 {
             /* Stacked box */
            transform: translate3d(180px, calc(var(--box-size)/-2 - var(--box-size)), -50px);
         }
         #box4 {
            transform: translate3d(50px, calc(var(--box-size)/-2), 200px);
         }

    </style>
</head>
<body>
    <div id="instructions">
        <b>Controls:</b><br>
        W / Up Arrow: Move Forward<br>
        S / Down Arrow: Move Backward<br>
        A / Left Arrow: Turn Left<br>
        D / Right Arrow: Turn Right
    </div>

    <div class="scene">
        <div class="world">
            <div class="map-element floor"></div>
             <div class="map-element ceiling"></div> <div class="map-element wall wall-front"></div>
            <div class="map-element wall wall-back"></div>
            <div class="map-element wall wall-left"></div>
            <div class="map-element wall wall-right"></div>

            <div class="map-element box" id="box1">
                <div class="box-face face-front"></div><div class="box-face face-back"></div>
                <div class="box-face face-left"></div><div class="box-face face-right"></div>
                <div class="box-face face-top"></div><div class="box-face face-bottom"></div>
            </div>
            <div class="map-element box" id="box2">
                <div class="box-face face-front"></div><div class="box-face face-back"></div>
                <div class="box-face face-left"></div><div class="box-face face-right"></div>
                <div class="box-face face-top"></div><div class="box-face face-bottom"></div>
            </div>
             <div class="map-element box" id="box3"> <div class="box-face face-front"></div><div class="box-face face-back"></div>
                <div class="box-face face-left"></div><div class="box-face face-right"></div>
                <div class="box-face face-top"></div><div class="box-face face-bottom"></div>
            </div>
             <div class="map-element box" id="box4">
                <div class="box-face face-front"></div><div class="box-face face-back"></div>
                <div class="box-face face-left"></div><div class="box-face face-right"></div>
                <div class="box-face face-top"></div><div class="box-face face-bottom"></div>
            </div>

            </div>
    </div>

    <script>
        const world = document.querySelector('.world');
        const scene = document.querySelector('.scene');

        // --- Player State ---
        let playerX = 0; // Player's position in the world
        let playerZ = 0;
        let playerY = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--player-height')); // Height off ground
        let playerAngleY = 0; // Player's looking direction (degrees)
        let moveSpeed = 4.5; // Units per frame
        let turnSpeed = 2.5; // Degrees per frame

        // --- Input State ---
        const keysPressed = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // --- Map Boundaries (from CSS variables) ---
        const mapWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--map-width'));
        const mapDepth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--map-depth'));
        const wallBuffer = 20; // Prevent getting stuck right on the edge

        const boundary = {
            xMin: -mapWidth / 2 + wallBuffer,
            xMax: mapWidth / 2 - wallBuffer,
            zMin: -mapDepth / 2 + wallBuffer,
            zMax: mapDepth / 2 - wallBuffer
        };


        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'w':
                case 'ArrowUp':
                    keysPressed.forward = true;
                    break;
                case 's':
                case 'ArrowDown':
                    keysPressed.backward = true;
                    break;
                case 'a':
                case 'ArrowLeft':
                    keysPressed.left = true;
                    break;
                case 'd':
                case 'ArrowRight':
                    keysPressed.right = true;
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'w':
                case 'ArrowUp':
                    keysPressed.forward = false;
                    break;
                case 's':
                case 'ArrowDown':
                    keysPressed.backward = false;
                    break;
                case 'a':
                case 'ArrowLeft':
                    keysPressed.left = false;
                    break;
                case 'd':
                case 'ArrowRight':
                    keysPressed.right = false;
                    break;
            }
        });

        // --- Game Loop ---
        function gameLoop() {
            let dx = 0;
            let dz = 0;
            let angleRad = playerAngleY * Math.PI / 180; // Convert degrees to radians

            // Calculate movement delta based on direction and speed
            if (keysPressed.forward) {
                dx += Math.sin(angleRad) * moveSpeed;
                dz += Math.cos(angleRad) * moveSpeed;
            }
            if (keysPressed.backward) {
                dx -= Math.sin(angleRad) * moveSpeed;
                dz -= Math.cos(angleRad) * moveSpeed;
            }

            // Calculate turning
            if (keysPressed.left) {
                playerAngleY -= turnSpeed;
            }
            if (keysPressed.right) {
                playerAngleY += turnSpeed;
            }

            // Calculate potential new position
            let nextPlayerX = playerX + dx;
            let nextPlayerZ = playerZ + dz;

            // --- Simple Boundary Collision Detection ---
            if (nextPlayerX > boundary.xMin && nextPlayerX < boundary.xMax) {
                 playerX = nextPlayerX;
            }
            if (nextPlayerZ > boundary.zMin && nextPlayerZ < boundary.zMax) {
                 playerZ = nextPlayerZ;
            }
            // NOTE: No collision with boxes is implemented here!

            // Update the world's transform to simulate camera movement
            // We move the world in the opposite direction of the player
            // We rotate the world opposite to the player's view angle
            // We translate the world UP by the player's height
            world.style.transform = `translateY(${-playerY}px) rotateY(${-playerAngleY}deg) translateX(${-playerX}px) translateZ(${-playerZ}px)`;

            // Request the next frame
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
